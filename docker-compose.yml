# Dockerfile para el Frontend (React.js)
# Ubicar este archivo en la raíz de la carpeta 'frontend'

# Etapa 1: Construir la aplicación React
FROM node:18-alpine AS build

WORKDIR /app

# Copia los archivos de manifiesto de dependencias y los instala
COPY package.json ./
COPY package-lock.json ./
RUN npm install

# Copia el resto del código del frontend
COPY . .

# Construye la aplicación React para producción
RUN npm run build

# Etapa 2: Servir la aplicación con Nginx
FROM nginx:alpine

# Copia la configuración de Nginx
# Asegúrate de crear este archivo en tu carpeta 'frontend/nginx/nginx.conf'
# Ve la configuración de Nginx más abajo en este mismo documento.
COPY nginx/nginx.conf /etc/nginx/conf.d/default.conf

# Copia los archivos construidos de la aplicación React al directorio de Nginx
COPY --from=build /app/build /usr/share/nginx/html

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```nginx
# Configuración de Nginx para el Frontend
# Guardar como: frontend/nginx/nginx.conf

server {
    listen 80;
    server_name localhost; # Puede ser la IP del contenedor o un dominio en producción

    # Directorio raíz donde Nginx buscará los archivos estáticos del frontend
    root /usr/share/nginx/html;
    index index.html index.htm;

    # Intenta servir el archivo solicitado, si no existe, redirige a index.html
    # Esto es necesario para las rutas de React (SPA)
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Proxy inverso para el backend
    # El nombre 'backend' aquí se resolverá al servicio 'backend' definido en docker-compose
    location /api/ {
        proxy_pass http://backend:3001/; # 'backend' es el nombre del servicio en docker-compose
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Configuración para servir archivos subidos (carátulas, PDFs generados) desde el volumen compartido
    # Asegúrate de que el backend guarda los archivos en un subdirectorio llamado 'uploads'
    # que es mapeado desde el volumen persistente.
    location /uploads/ {
        alias /var/www/tuu-capricho/backend/uploads/; # Ruta dentro del contenedor del backend donde están los uploads
    }

    # Configuración para servir templates predefinidos
    location /templates/ {
        alias /var/www/tuu-capricho/backend/templates/; # Ruta dentro del contenedor del backend donde están los templates
    }
}
```docker
# Dockerfile para el Backend (Node.js/Express)
# Ubicar este archivo en la raíz de la carpeta 'backend'

FROM node:18-alpine

WORKDIR /app

# Instala dependencias para pdfkit (requiere cairo, etc.)
# Esto asegura que las librerías necesarias estén disponibles en el contenedor
RUN apk add --no-cache python3 make g++ libcairo-dev libjpeg-turbo-dev libpango1.0-dev libgif-dev

# Copia los archivos de manifiesto de dependencias y los instala
COPY package.json ./
COPY package-lock.json ./
RUN npm install --production

# Copia el resto del código del backend
COPY . .

# Crea los directorios de uploads si no existen (Multer los usará)
RUN mkdir -p uploads/covers uploads/agendas

# Expone el puerto que usa tu aplicación Node.js
EXPOSE 3001

# Comando para iniciar la aplicación
# Usaremos 'node src/app.js' directamente, pero puedes usar PM2 si prefieres.
# Si usas PM2, necesitarías instalarlo globalmente en el Dockerfile: RUN npm install -g pm2
# y el CMD sería: CMD ["pm2-runtime", "src/app.js"]
CMD ["node", "src/app.js"]
```yaml
# docker-compose.yml
# Ubicar este archivo en la raíz del repositorio (donde están las carpetas frontend y backend)

version: '3.8'

services:
  # Servicio de la base de datos PostgreSQL
  db:
    image: postgres:13-alpine # Usa una imagen de PostgreSQL estable y ligera
    environment:
      POSTGRES_DB: tuu_capricho_db
      POSTGRES_USER: tuu_capricho_user
      POSTGRES_PASSWORD: tu_contraseña_segura_docker # ¡CAMBIA ESTO!
    ports:
      - "5432:5432" # Mapea el puerto del contenedor al host
    volumes:
      - db_data:/var/lib/postgresql/data # Persistencia de datos de la DB
    healthcheck: # Comprobación de salud para esperar a que la DB esté lista
      test: ["CMD-SHELL", "pg_isready -U tuu_capricho_user -d tuu_capricho_db"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Servicio del Backend (Node.js/Express)
  backend:
    build:
      context: ./backend # Ruta al Dockerfile del backend
      dockerfile: Dockerfile
    ports:
      - "3001:3001" # Mapea el puerto del contenedor al host (opcional, Nginx lo proxeará)
    environment:
      PORT: 3001
      DB_USER: tuu_capricho_user
      DB_HOST: db # Nombre del servicio de la DB en docker-compose
      DB_NAME: tuu_capricho_db
      DB_PASSWORD: tu_contraseña_segura_docker # ¡DEBE COINCIDIR CON EL DE LA DB!
      DB_PORT: 5432
    volumes:
      - ./backend/uploads:/app/uploads # Persistencia para archivos subidos (carátulas, PDFs generados)
      - ./backend/templates:/app/templates # Si tienes templates predefinidos
    depends_on:
      db:
        condition: service_healthy # Espera a que la DB esté saludable
    restart: always # Siempre reinicia el contenedor si se detiene

  # Servicio del Frontend (React.js)
  frontend:
    build:
      context: ./frontend # Ruta al Dockerfile del frontend
      dockerfile: Dockerfile
    ports:
      - "80:80" # Expone el puerto 80 del contenedor al puerto 80 del host
    environment:
      REACT_APP_API_URL: http://localhost/api # Nginx en el frontend proxeará a /api, que apunta al backend
    depends_on:
      - backend # El frontend depende del backend (aunque Nginx es el que hace la llamada)
    restart: always # Siempre reinicia el contenedor si se detiene

volumes:
  db_data: # Define el volumen para los datos de PostgreSQL
